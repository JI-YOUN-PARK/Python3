from collections import deque


n, m = map(int, input().split())

graph = []
for i in range(n):
    graph.append(list(map(int, input())))

dx=[-1,1,0,0] # x좌표는 상하좌우中 '상/하'에만 영향을 받는다
dy=[0,0,-1,1] # y좌표는 상하좌우中 '좌/우'에만 영향을 받는다
# --------------------------------------------------------------------#
def bfs(x,y):
    queue=deque()
    queue.append((x,y))

    while queue:
        x,y=queue.popleft()

        for i in range(4):
            new_x = x + dx[i]
            new_y = y + dy[i]

            # 공간 벗어나면 무시
            if new_x<0 or new_y<0 or new_x>=n or new_y>=m:
                continue

            # 괴물이 존재한다면 무시
            if graph[new_x][new_y] == 0:
                continue

            # 갈 수 있는 공간일 때
            if graph[new_x][new_y] == 1:

                #'BFS를 계속 수행하면 결과적으로 다음과 같이 최단 경로의 값들이 1씩 증가하는 형태로 변경된다."
                graph[new_x][new_y] = graph[new_x][new_y]+1
                queue.append((new_x,new_y))

    return graph[n-1][m-1]


print(bfs(0,0)) #bfs(0,0)인 이유 : 지문 왈 '(1,1)에서 항상 시작'. 이는 코딩에서 (0,0)의 위치다.
