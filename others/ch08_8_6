n=int(input())
array=list(map(int,input().split()))
d=[0]*15

d[0]=array[0]
d[1]=max(array[0],array[1])

for i in range(2,n):

    # max(d[i-1],d[i-2]+array[i])
    # 이 아이디어를 통해 (등차 1)일 경우, (등차 2)일 경우 모두 커버 가능해진다.
    # [why?] [0]*10인 배열이 있다고 하자. 이때, 첫 칸부터 시작해 (등차 1)로 진행하면 마지막 [i]는 더할 수 없다.
    # 그런데 (등차 2)로 진행하면 i를 더할 수 있다. 그래서  배열 크기가 2일 때부터 시작해 10일 때까지 
    # max(d[i-1],d[i-2]+array[i]) 이 2가지 경우 중 어느것이 더 큰지 지속적으로 업데이터를 하는 것이다.
    
    # Q) [0]*11이면 어떻게 되나? 
    # A) 그림을 그려보면 이 또한 max(d[i-1],d[i-2]+array[i])에 적용됨을 알 수 있다.
    d[i]=max(d[i-1],d[i-2]+array[i])

print(d[n-1])
